#!/usr/bin/php
<?php
//----------------------------------------------------------------------------------------------------------------------
/** Throws an execption. Arguments similair to printf.
 */
function set_assert_failed()
{
  $args    = func_get_args();
  $format  = array_shift( $args );
  $message = vsprintf( $format,  $args );

  throw new Exception( $message );
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Klasse met wrapper functies voor alle stored procedures die aangeroepen mogen worden door PHP-code.
 */
class SET_DL
{
  /** Referentie naar een mysqli object (zie Connect) dat gebruikt wordt voor het afvuren van alle SQL satements in
   *  deze klasse.
   */
  private static $ourMySql;

  //--------------------------------------------------------------------------------------------------------------------
  /** Werpt een excptie met de huidige error code en beschrijving van $ourMySql.
   */
  private static function ThrowSqlError( $theText )
  {
    $message  = "MySQL Error no: ".self::$ourMySql->errno."\n";
    $message .= self::$ourMySql->error;
    $message .= "\n";
    $message .= $theText."\n";

    throw new Exception( $message );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Wrapper om mysqli::query. Indien de call naar mysqli::query mislukt wordt een een exceptie geworpen.
   */
  private static function Query( $theQuery )
  {
    $ret = self::$ourMySql->query( $theQuery );
    if ($ret===false) self::ThrowSqlError( $theQuery );

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Wrapper om mysqli::real_query. Indien de call naar mysqli::real_query mislukt wordt een een exceptie geworpen.
   */
  private static function RealQuery( $theQuery )
  {
    $tmp = self::$ourMySql->real_query( $theQuery );
    if ($tmp===false) self::ThrowSqlError( $theQuery );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Start een transactie in MySQL.
   */
  public static function Begin()
  {
    $ret = self::$ourMySql->autocommit(false);
    if (!$ret) self::ThrowSqlError( 'autocommit' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Commit de huidige transactie in MySQL.
   */
  public static function Commit()
  {
    $ret = self::$ourMySql->commit();
    if (!$ret) self::ThrowSqlError( 'commit' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Connecteert naar de MySQL server (parameters @a $theHostName, @a $theUserName, @a $thePassWord en @a $theDatabase)
   *  en voert een aantal initialisaties uit.
   */
  public static function Connect( $theHostName, $theUserName, $thePassWord, $theDatabase )
  {
    self::$ourMySql = new mysqli( $theHostName, $theUserName, $thePassWord, $theDatabase );
    if (!self::$ourMySql) self::ThrowSqlError( 'init' );

    $ret = self::$ourMySql->options(MYSQLI_OPT_CONNECT_TIMEOUT, 600);
    if (!$ret) self::ThrowSqlError( 'options' );

    $ret = self::$ourMySql->set_charset("utf8");
    if (!$ret) self::ThrowSqlError( 'set_charset' );
    /*
    $ret = self::ExecuteNone( "set sql_mode = '".SET_SQL_MODE."'");

    // The default transaction level is REPEATABLE-READ. Set transaction level to READ-COMMITED.
    self::ExecuteNone( "SET tx_isolation = 'READ-COMMITTED'" );

    // Disable query caching.
    self::ExecuteNone( "set query_cache_type = 0" );*/
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Indien er een verbinding is met een MySQL server, verbreekt de verbinding.
   */
  public static function Disconnect()
  {
    if (self::$ourMySql)
    {
      self::$ourMySql->close();
      self::$ourMySql = null;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Voert query @a $theQuery uit. @a $theQuery mag 0 of meer rijen teruggeven.
   */
  public function ExecuteRows( $theQuery )
  {
    $result = self::Query( $theQuery );
    $ret = array();
    while($row = $result->fetch_array( MYSQLI_ASSOC )) $ret[] = $row;
    $result->close();

    self::$ourMySql->next_result();

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Voert query @a $theQuery uit een geeft het aantal "affected rows" terug. @a $theQuery mag geen rijen teruggeven.
   */
  public function ExecuteNone( $theQuery )
  {
    self::Query( $theQuery );

    $n = self::$ourMySql->affected_rows;

    self::$ourMySql->next_result();

    return $n;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Voert query @a $theQuery uit. De query mag een multi query zijn (b.v. een store procedure) en de output van de
   *  query wordt gelogt.
   */
  public static function ExecuteEcho( $theQuery )
  {
    $ret = self::$ourMySql->multi_query( $theQuery );
    if (!$ret) self::ThrowSqlError( $theQuery );
    do
    {
      $result = self::$ourMySql->store_result();
      if (self::$ourMySql->errno) self::ThrowSqlError( '$mysqli->store_result failed for \''.$theQuery.'\'' );
      if ($result)
      {
        $fields = $result->fetch_fields();
        while ($row = $result->fetch_row())
        {
          $line = '';
          foreach( $row as $i => $field )
          {
            if ($i>0) $line .= ' ';
            $line .= str_pad( $field, $fields[$i]->max_length );
          }
          etl_log( $line );
        }
        $result->free();
      }
    }
    while (self::$ourMySql->next_result());
    if (self::$ourMySql->errno) self::ThrowSqlError( '$mysqli->next_result failed for \''.$theQuery.'\'' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief The class creates a file which contains all used constants with values.
 */
class SET_ConfigConstants
{
  /** Filename with columnnames, theirs widths, and constant names.
   */
  private $myConstsFileName;

  /** Template file name under which the file is generated with the constants.
   */
  private $myTemplateConfigFileName;

  /** Name of file that contains all constants.
   */
  private $myConfigFileName;

  /** All columns in the MySQL schema.
   */
  private $myColumns = array();

  /** Array with the previous columnnames,  widths, and constant names (i.e. the content of @c $myConstsFileName upon
   *  starting this program).
   */
  private $myOldColumns = array();

  /** Array with all constants.
   */
  private $myConstants = array ();

  /** The prefix used  for designations a unknown constants.
   */
  private $myPrefix;

  /**
   */
   private $myLabels = array();

  /** @name MySQL
     @{
     MySQL database settings.
   */

  /** Host name or addres.
   */
  private $myHostName;
  /** User name.
   */
  private $myUserName;
  /** Uesr password.
   */
  private $myPassWord;
  /** Name used databae.
   */
  private $myDatabase;
  /** @} */

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns the value of a setting.
      @param $theSettings      The settings as returned by @c parse_ini_file.
      @param $theMandatoryFlag If set and setting @a $theSettingName is not found in section @a $theSectionName an
                               exception will be thrown.
      @param $theSectionName   The name of the section of the requested setting.
      @param $theSettingName   The name of the setting of the requested setting.
   */
  private function GetSetting( $theSettings, $theMandatoryFlag, $theSectionName, $theSettingName )
  {
    // Test if the section exists.
    if (!array_key_exists( $theSectionName, $theSettings ))
    {
      if ($theMandatoryFlag)
      {
        set_assert_failed( "Section '%s' not found in configuration file.", $theSectionName );
      }
      else
      {
        return null;
      }
    }

    // Test if the setting in the section exists.
    if (!array_key_exists( $theSettingName, $theSettings[$theSectionName] ))
    {
      if ($theMandatoryFlag)
      {
        set_assert_failed( "Setting '%s' not found in section '%s' configuration file.", $theSettingName,
                                                                                         $theSectionName );
      }
      else
      {
        return null;
      }
    }

    return $theSettings[$theSectionName][$theSettingName];
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Reads parameters from configuration @a $theConfigFileName
   */
  private function ReadConfigFile( $theConfigFileName )
  {
    $settings = parse_ini_file( $theConfigFileName, true );
    if ($settings===false) set_assert_failed( "Unable open configuration file" );

    $this->myHostName = $this->GetSetting( $settings, true,  'database', 'host_name');
    $this->myUserName = $this->GetSetting( $settings, true,  'database', 'user_name');
    $this->myPassWord = $this->GetSetting( $settings, true,  'database', 'password');
    $this->myDatabase = $this->GetSetting( $settings, true,  'database', 'database_name');

    $this->myConstsFileName       = $this->GetSetting( $settings, true,  'constants', 'columns');
    $this->myPrefix               = $this->GetSetting( $settings, true,  'constants', 'prefix');
    $this->myTemplateConfigFileName = $this->GetSetting( $settings, true,  'constants', 'config_template');
    $this->myConfigFileName       = $this->GetSetting( $settings, true,  'constants', 'config');
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get all columns with data from table in MySQL into @a myColumns.
   */
  private function GetColumns()
  {
    $query = "
select table_name
,      column_name
,      data_type
,      character_maximum_length
,      numeric_precision
from   information_schema.COLUMNS
where  table_schema = database()
and    table_name  rlike '^[a-zA-Z0-9_]*$'
and    column_name rlike '^[a-zA-Z0-9_]*$'
order by table_name
,        ordinal_position";

    $rows = SET_DL::ExecuteRows( $query );
    foreach( $rows as $row )
    {
      $row['length'] = $this->DeriveFieldLength( $row );
      $this->myColumns[$row['table_name']][$row['column_name']] = $row;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get the length of the field, depending on its type.
   */
  private function DeriveFieldLength( $theColumn )
  {
    $ret = null;
    switch ($theColumn['data_type'])
    {
    case 'tinyint':
    case 'smallint':
    case 'mediumint':
    case 'int':
    case 'bigint':

    case 'decimal':
    case 'float':
    case 'double':
      $ret = $theColumn['numeric_precision'];
      break;

    case 'char':
    case 'varchar':
    case 'binary':
    case 'varbinary':

    case 'tinytext':
    case 'text':
    case 'mediumtext':
    case 'longtext':
    case 'tinyblob':
    case 'blob':
    case 'mediumblob':
    case 'longblob':
    case 'bit':
      $ret = $theColumn['character_maximum_length'];
      break;

    case 'timestamp':
      $ret = 16;
      break;

    case 'year':
      $ret = 4;
      break;

    case 'time':
      $ret = 8;
      break;

    case 'date':
      $ret = 10;
      break;

    case 'datetime':
      $ret = 16;
      break;

    case 'enum':
    case 'set':
      // Nothing to do. We don't assign a width to column of enum type.
      break;

    default:
      set_assert_failed( "Unknown type '%s'.", $theColumn['data_type'] );
    }

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Record constants and their values to the file @a myConstsFileName.
   */
  private function WriteColumns()
  {
    $temp_filename = $this->myConstsFileName.'.tmp';
    $handle = fopen( $temp_filename, 'w' );
    if ($handle===null) set_assert_failed( "Unable to open file '%s'.", $this->myConstsFileName );

    foreach( $this->myColumns as $table )
    {
      $width1 = 0;
      $width2 = 0;
      foreach( $table as $column )
      {
        $width1 = max( strlen( $column['column_name'] ), $width1 );
        $width2 = max( strlen( $column['length'] ),      $width2 );
      }

      foreach( $table as $column )
      {
        if (isset($column['length']))
        {
          if (isset($column['constant_name']))
          {
            $line_format = sprintf( "%%s.%%-%ds %%%dd %%s\n", $width1, $width2 );
            $n = fprintf( $handle, $line_format, $column['table_name'],
                                                 $column['column_name'],
                                                 $column['length'],
                                                 $column['constant_name'] );
            if ($n===false) set_assert_failed( "Error writing file '%s'.", $this->myConstsFileName );
          }
          else
          {
            $line_format = sprintf( "%%s.%%-%ds %%%dd\n", $width1, $width2 );
            $n = fprintf( $handle, $line_format, $column['table_name'], $column['column_name'], $column['length'] );
            if ($n===false) set_assert_failed( "Error writing file '%s'.", $this->myConstsFileName );
          }
        }
      }

      $n = fprintf( $handle, "\n" );
      if ($n===false) set_assert_failed( "Error writing file '%s'.", $this->myConstsFileName );
    }

     $err = fclose( $handle );
     if ($err===false) set_assert_failed( "Error closing file '%s'.", $this->myConstsFileName );

     $err = rename( $this->myConstsFileName.'.tmp', $this->myConstsFileName );
     if ($err===false) set_assert_failed( "Error: can't rename file '%s' to '%s'.", $temp_filename,
                                                                                    $this->myConstsFileName );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get old column with consatant from file @a myConstsFileName
   */
  private function GetOldColumns()
  {
    if (file_exists( $this->myConstsFileName ))
    {
      $handle = fopen( $this->myConstsFileName, 'r' );
      if ($handle===null) set_assert_failed( "Unable to open file '%s'.", $this->myConstsFileName );

      $line_number = 0;
      while( $line = fgets( $handle ) )
      {
        $line_number++;
        if ($line!="\n")
        {
          $n = preg_match( "/^\s*([a-zA-Z0-9_]+).([a-zA-Z0-9_]+)\s+(\d+)\s*(\*|[a-zA-Z0-9_]+)?\s*$/", $line, $matches );
          if ($n===false) set_assert_failed( 'Internal error.' );

          if ($n==0)
          {
            echo $line;
            echo sprintf( "Illegal format at line %d in the file '%s'.\n", $line_number, $this->myConstsFileName );
          }

          if (isset($matches[4]))
          {
            $table_name    = $matches[1];
            $column_name   = $matches[2];
            $length        = $matches[3];
            $constant_name = $matches[4];

            $this->myOldColumns[$table_name][$column_name] = array( 'table_name'    => $table_name,
                                                                    'column_name'   => $column_name,
                                                                    'length'        => $length,
                                                                    'constant_name' => $constant_name );
          }
        }
      }
      $err = fclose( $handle );
      if ($err===false) set_assert_failed( "Error closing file '%s'.", $this->myConstsFileName );
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Definition a unknown constants.
   */
  private function EnhanceColumns()
  {
    foreach( $this->myOldColumns as $table )
    {
      foreach( $table as $column )
      {
        $table_name  = $column['table_name'];
        $column_name = $column['column_name'];

        if ($column['constant_name']=='*')
        {
          $constant_name = strtoupper( $this->myPrefix.$column['column_name'] );
          $this->myOldColumns[$table_name][$column_name]['constant_name'] = $constant_name;
        }
        else
        {
          $constant_name = strtoupper( $this->myOldColumns[$table_name][$column_name]['constant_name']);
          $this->myOldColumns[$table_name][$column_name]['constant_name'] = $constant_name;
        }
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Merges the columns with the old and new constants.
   */
  private function MergeColumns()
  {
    foreach( $this->myOldColumns as $table_name => $table )
    {
      foreach( $table as $column_name => $column )
      {
        if (isset( $this->myColumns[$table_name][$column_name] ))
        {
          $this->myColumns[$table_name][$column_name]['constant_name'] = $column['constant_name'];
        }
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get all lable from the MySQL.
   */
  private function GetLabels()
  {
    $query_string = "
select t1.table_name  `table_name`
,      t1.column_name `id`
,      t2.column_name `label`
from       information_schema.columns t1
inner join information_schema.columns t2 on t1.table_name = t2.table_name
where t1.table_schema = database()
and   t1.extra        = 'auto_increment'
and   t2.table_schema = database()
and   t2.column_name like '%%\_label'";

    $tables = SET_DL::ExecuteRows( $query_string );
    foreach( $tables as $table )
    {
      $query_string = "
select `%s`  as `id`
,      `%s`  as `label`
from   `%s`
where   nullif(`%s`,'') is not null";

      $query_string = sprintf( $query_string, $table['id'], $table['label'], $table['table_name'], $table['label'] );
      $rows = SET_DL::ExecuteRows( $query_string );
      foreach ( $rows as $row )
      {
        $this->myLabels[$row['label']] = $row['id'];
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get all known constants into the array myConstants.
   */
  private function FillConstants()
  {
    foreach( $this->myColumns as $table_name => $table )
    {
      foreach( $table as $column_name => $column )
      {
        if (isset($this->myColumns[$table_name][$column_name]['constant_name']))
        {
          $this->myConstants[$column['constant_name']] = $column['length'];
        }
      }
    }

    foreach( $this->myLabels as $label => $id )
    {
      $this->myConstants[$label] = $id;
    }

    $ok = ksort( $this->myConstants );
    if ($ok===false) set_assert_failed( 'Internal error.' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Automatic generation the constants.
   */
  private function WriteTargetConfigFile()
  {
    $source = file_get_contents( $this->myTemplateConfigFileName );
    if ($source===false) set_assert_failed( "Unable to open file '%s'.", $this->myTemplateConfigFileName );

    $width1 = 0;
    $width2 = 0;
    $constants = '';
    foreach( $this->myConstants as $constant => $value )
    {
      $width1 = max( strlen( $constant ), $width1 );
      $width2 = max( strlen( $value ),    $width2 );
    }

    $line_format = sprintf( "const %%-%ds = %%%dd; \n", $width1, $width2 );
    foreach( $this->myConstants as $constant => $value )
    {
      $constants .= sprintf( $line_format, $constant, $value );
    }

    $source = str_replace( '/* AUTO_GENERATED_CONSTS */', $constants, $source );

    $ok = file_put_contents( $this->myConfigFileName,  $source );
    if ($ok===false) set_assert_failed( "Unable to write to file '%s'.", $this->myTemplateConfigFileName );
  }

  //--------------------------------------------------------------------------------------------------------------------
  public function Run( $theConfigFileName )
  {
    $this->ReadConfigFile( $theConfigFileName );

    SET_DL::Connect( $this->myHostName, $this->myUserName, $this->myPassWord, $this->myDatabase );

    $this->GetOldColumns();

    $this->GetColumns();

    $this->EnhanceColumns();

    $this->MergeColumns();

    $this->WriteColumns();

    $this->GetLabels();

    $this->FillConstants();

    $this->WriteTargetConfigFile();

    SET_DL::Disconnect();

    return 0;
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for loading stored routine into a MySQL instance from pseudo SQL files (.psql).
 */
class SET_RoutineLoader
{
  /** @name Settings
     @{
     Properties for settings.
  */

  /** Path where .psql files can be found.
  */
  private $myIncludePath;

  /** The name of the file with SQL statement to retreive table and column names, and column types.
   */
  private $mySqlColumnTypeFileName;

  /** The SQL mode under which the stored routine will be loaded and run.
   */
  private $mySqlMode;

  /** The default character set under which the stored routine will be loaded and run.
   */
  private $myCharacterSet;

  /** The default collate under which the stored routine will be loaded and run.
   */
  private $myCollate;

  /** The name of the configuration file of the target porject
   */
  private $myTargetConfigFileName;
  /** @} */


  /** @name Overall
     @{
     Properties with data about all stored routines and .psql files.
   */

  /** An array with all found .psql files.
   */
  private $myPsqlFileNames = array();

  /** The filename of the file with the metadata of all stored routines.
   */
  private $myMetadataFilename;

  /** Array with the metadata of all stored routines.
   */
  private $myMetadata = array();

  /** A map from placeholders to their actual values.
   */
  private $myReplacePairs = array();

  /** An array with psql filenames that are not loaded into MySQL.
   */
  private $myErrorFileNames = array();

  /** Information about old routines.
   */
  private $myOldRoutines;
  /** @} */


  /** @name Current
     @{
     Properties with data about the current stored routine and/or .psql file.
  */
  /** The current .psql filename.
   */
  private $myCurrentPsqlFileName;

  /** The source code as a single string of the current .psql file.
   */
  private $myCurrentPsqlSourceCode;

  /** The source code as an array of lines string of the current .psql file.
   */
  private $myCurrentPsqlSourceCodeLines;

  /** The placeholders in the current .psql file.
   */
  private $myCurrentPlaceholders;

  /** The designation type of the stored routine in the current .psql file.
   */
  private $myCurrentType;

  /** The routine type (i.e. procedure or function) of the stored routine in the current .psql file.
   */
  private $myCurrentRoutineType;

  /** The name of the stored routine in the current .psql file.
   */
  private $myCurrentRoutineName;

  /** The key or index columns (depending on the designation type) of the stored routine in the current .psql file.
   */
  private $myCurrentColumns;

  /** The last modification time of the current .psql file.
   */
  private $myCurrentMtime;

  /** The replace pairs (i.e. placeholders and their actual values, see strst) for the current .psql file.
   */
  private $myCurrentReplace = array();

  /** The old metadata of the current .psql file.
   */
  private $myCurrentOldMetadata;
  /** @} */

  /** @name MySQL
     @{
     MySQL database settings.
  */

  /** Host name or addres.
   */
  private $myHostName;
  /** User name.
   */
  private $myUserName;
  /** Uesr password.
   */
  private $myPassWord;
  /** Name used databae.
   */
  private $myDatabase;
  /** @} */

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns the value of a setting.
      @param $theSettings      The settings as returned by @c parse_ini_file.
      @param $theMandatoryFlag If set and setting @a $theSettingName is not found in section @a $theSectionName an
                               exception will be thrown.
      @param $theSectionName   The name of the section of the requested setting.
      @param $theSettingName   The name of the setting of the requested setting.
   */
  private function GetSetting( $theSettings, $theMandatoryFlag, $theSectionName, $theSettingName )
  {
    // Test if the section exists.
    if (!array_key_exists( $theSectionName, $theSettings ))
    {
      if ($theMandatoryFlag)
      {
        set_assert_failed( "Section '%s' not found in configuration file.", $theSectionName );
      }
      else
      {
        return null;
      }
    }

    // Test if the setting in the section exists.
    if (!array_key_exists( $theSettingName, $theSettings[$theSectionName] ))
    {
      if ($theMandatoryFlag)
      {
        set_assert_failed( "Setting '%s' not found in section '%s' configuration file.", $theSettingName,
                                                                                         $theSectionName );
      }
      else
      {
        return null;
      }
    }

    return $theSettings[$theSectionName][$theSettingName];
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Reads parameters from configuration @a $theConfigFileName
   */
  private function ReadConfigFile( $theConfigFileName )
  {
    $settings = parse_ini_file( $theConfigFileName, true );
    if ($settings===false) set_assert_failed( "Unable open configuration file" );

    $this->myHostName = $this->GetSetting( $settings, true,  'database', 'host_name');
    $this->myUserName = $this->GetSetting( $settings, true,  'database', 'user_name');
    $this->myPassWord = $this->GetSetting( $settings, true,  'database', 'password');
    $this->myDatabase = $this->GetSetting( $settings, true,  'database', 'database_name');

    $this->myMetadataFilename      = $this->GetSetting( $settings, true,  'wrapper', 'metadata');
    $this->myIncludePath           = $this->GetSetting( $settings, true,  'loader',  'psql' );
    $this->mySqlColumnTypeFileName = $this->GetSetting( $settings, true,  'loader',  'column_types_sql' );
    $this->myTargetConfigFileName  = $this->GetSetting( $settings, false, 'loader',  'config' );
    $this->mySqlMode               = $this->GetSetting( $settings, true,  'loader',  'sql_mode');
    $this->myCharacterSet          = $this->GetSetting( $settings, true,  'loader',  'character_set' );
    $this->myCollate               = $this->GetSetting( $settings, true,  'loader',  'collate' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Reads constants set in @c myTargetConfigFileName and adds them to @c myReplacePairs.
   */
  private function GetConstants()
  {
    // If myTargetConfigFileName is not set return immediatly.
    if (!isset($this->myTargetConfigFileName)) return;

    if (!is_readable( $this->myTargetConfigFileName )) set_assert_failed( "Configuration file is not readable '%s'.",
                                                                           $this->myTargetConfigFileName );

    require_once( $this->myTargetConfigFileName );
    $constants    = get_defined_constants(true);
    $user_defined = (isset($constants['user'])) ? $constants['user'] : array();

    foreach( $user_defined as $name => $value )
    {
      if (!is_numeric( $value )) $value = "'$value'";

      $this->myReplacePairs['@'.$name.'@'] = $value;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Searches recursively for all .psql files under directory @p $theSourceDir.
   */
  private function FindPsqlFiles( $theSourceDir=null )
  {
    if($theSourceDir===null) $theSourceDir = $this->myIncludePath;

    $psql_file_names = glob( "$theSourceDir/*.psql" );
    foreach( $psql_file_names as $psql_file_name )
    {
      $base_name = basename( $psql_file_name, '.psql' );
      if (!isset($this->myPsqlFileNames[$base_name]))
      {
        $this->myPsqlFileNames[$base_name] = $psql_file_name;
      }
      else
      {
        echo sprintf( "Error: Files '%s' and '%s' have the same basename.\n",
                      $this->myPsqlFileNames[$base_name],
                      $psql_file_name );
        $this->myErrorFileNames[] = $psql_file_name;
      }
    }

    $file_names = scandir( $theSourceDir );
    $dir_names = array();
    foreach( $file_names as $file_name )
    {
      if (is_dir( $theSourceDir.'/'.$file_name ))
      {
        if ($file_name!='.' && $file_name!='..')
        {
          $dir_names[] = $theSourceDir.'/'.$file_name;
        }
      }
    }

    foreach( $dir_names as $dir_name )
    {
      $this->FindPsqlFiles( $dir_name );
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns the metadata @a myMetadata of stored routines stored in file.
   */
  private function ReadRoutineMetaData()
  {
    $this->myMetadata = array();

    if (file_exists( $this->myMetadataFilename ))
    {
      $handle = fopen( $this->myMetadataFilename, 'r' );
      if ($handle===null) set_assert_failed( "Unable to open file '%s'.", $this->myMetadataFilename );

      // Skip header row.
      fgetcsv( $handle );

      while (($row = fgetcsv( $handle ))!==false)
      {
        $this->myMetadata[$row[0]] = array( 'routine_name'   => $row[0],
                                            'type'           => $row[1],
                                            'argument_types' => $row[2],
                                            'columns'        => $row[3],
                                            'timestamp'      => $row[4],
                                            'replace'        => $row[5] );
      }

      $err = fclose( $handle );
      if ($err===false) set_assert_failed( "Error closing file '%s'.", $this->myMetadataFilename );
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Writes the stored routines metadata @c myMetadatae to file @c myMetadataFilename.
   */
  private function WriteRoutineMetadata()
  {
    $handle = fopen( $this->myMetadataFilename, 'w' );
    if ($handle===false) set_assert_failed( "Unable to open file '%s'.", $this->myMetadataFilename );

    $header = array( 'routine_name', 'type', 'argument_types', 'columns', 'timestamp', 'replace' );
    $n = fputcsv( $handle, $header  );
    if ($n===false) set_assert_failed( "Error writing file '%s'.", $this->myMetadataFilename );

    $ok = ksort( $this->myMetadata );
    if ($ok===false) set_assert_failed( 'Internal error.' );

    foreach( $this->myMetadata as $routine_propertys )
    {
      $n = fputcsv( $handle, $routine_propertys );
      if ($n===false) set_assert_failed( "Error writing file '%s'.", $this->myMetadataFilename );
    }

    $err = fclose( $handle );
    if ($err===false) set_assert_failed( "Error closing file '%s'.", $this->myMetadataFilename );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Exracts the placeholders from the current psql file and stored them in @c myCurrentPlaceholders.
      Returns @c true if all placeholders are defined, @c false otherwise.
  */
  private function GetCurrentPlaceholders()
  {
    $err = preg_match_all( "(@[A-Za-z0-9\_\.]+(\%type)?@)", $this->myCurrentPsqlSourceCode, $matches );
    if ($err===false) set_assert_failed( 'Internal error.' );

    $ret = true;
    $this->myCurrentPlaceholders = array();

    if (!empty($matches[0]))
    {
      foreach( $matches[0] as $placeholder )
      {
        if (!isset($this->myReplacePairs[strtoupper( $placeholder )]))
        {
          echo sprintf( "Error: Unknown placeholder '%s' in file '%s'.\n", $placeholder, $this->myCurrentPsqlFileName );
          $ret = false;
        }

        if (!isset($this->myCurrentPlaceholders[$placeholder]))
        {
          $this->myCurrentPlaceholders[$placeholder] = $placeholder;
        }
      }
    }

    if ($ret===true)
    {
      foreach( $this->myCurrentPlaceholders as $placeholder )
      {
        $this->myCurrentReplace[$placeholder] = $this->myReplacePairs[strtoupper( $placeholder )];
      }
      $ok = ksort( $this->myCurrentReplace );
      if ($ok===false) set_assert_failed( 'Internal error.' );
    }

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Extracts the designation type of the current stored routine and sets @c myCurrentType and @c myCurrentColumns.
      Returns @c true on success. Otherwise returns @c false.
   */
  private function GetCurrentType()
  {
    $ret = true;
    $key = array_search( 'begin', $this->myCurrentPsqlSourceCodeLines );

    if ($key!==false)
    {
      $n = preg_match( "/^\s*--\s+type:\s*(\w+)\s*([a-zA-Z0-9_,]+)?\s*/", $this->myCurrentPsqlSourceCodeLines[$key-1],
                                                                          $matches );
      if ($n===false) set_assert_failed( "Internal error." );

      if ($n==1)
      {
        $this->myCurrentType = $matches[1];
        if (isset($matches[2]))
        {
          $this->myCurrentColumns = $matches[2];
        }
      }
      else
      {
        $ret = false;
      }
    }
    else
    {
      $ret = false;
    }

    if ($ret===false)
    {
      echo sprintf( "Error: Unable to find the desgination type of the stored routine in file '%s'.",
                    $this->myCurrentPsqlFileName );
    }

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Extracts the name of the stored routine and the stored routine type (i.e. procedure or function) and sets
      @c myCurrentRoutineType and @c myCurrentRoutineName. Returns @c true on success. Otherwise returns @c false.

      @todo Skip comments and string literals.
   */
  private function GetCurrentName()
  {
    $ret = true;

    $n = preg_match( "/create\s+(procedure|function)\s+([a-zA-Z0-9_]+)/i", $this->myCurrentPsqlSourceCode, $matches );
    if ($n===false) set_assert_failed( 'Internal error.' );

    if ($n==1)
    {
      $this->myCurrentRoutineType = strtolower( $matches[1] );

      if ($this->myCurrentRoutineName!=$matches[2])
      {
        echo sprintf( "Error: Stored routine name '%s' does not match filename in file '%s'.\n",
                      $this->myCurrentRoutineName,
                      $this->myCurrentPsqlFileName );
        $ret = false;
      }
    }
    else
    {
      $ret = false;
    }

    if (!isset($this->myCurrentRoutineType))
    {
      echo sprintf( "Error: Unable to find the stored routine name and type in file '%s'.\n",
                    $this->myCurrentPsqlFileName );
    }

    return $ret;
  }
  //--------------------------------------------------------------------------------------------------------------------
  /** Drops the current routine if it exists.
   */
  private function DropCurrentRoutine()
  {
    if (isset($this->myOldRoutines[$this->myCurrentRoutineName]))
    {
      $sql = sprintf( "drop %s if exists %s",
                      $this->myOldRoutines[$this->myCurrentRoutineName]['routine_type'],
                      $this->myCurrentRoutineName );

      SET_DL::ExecuteNone( $sql );
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  private function LoadCurrentPsqlFile()
  {
    echo sprintf( "Loading %s %s\n",
                  $this->myCurrentRoutineType,
                  $this->myCurrentRoutineName );

    $sql_source = strtr( $this->myCurrentPsqlSourceCode, $this->myCurrentReplace );

    // Drop the stored procedure or function if its exists.
    $this->DropCurrentRoutine();

    // Set the SQL-mode under which the stored routine will run.
    $sql = sprintf( "set sql_mode ='%s'", $this->mySqlMode );
    SET_DL::ExecuteNone( $sql );

    // Set the default charaacter set and collate under which the store routine will run.
    $sql = sprintf( "set names '%s' COLLATE '%s'", $this->myCharacterSet, $this->myCollate );
    SET_DL::ExecuteNone( $sql );

    // Load the stored routine into MySQL.
    SET_DL::ExecuteNone( $sql_source );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns @c true if the current .psql file must be load or reloaded. Otherwise returns @c false.
   */
  private function GetCurrentMustReload()
  {
    // If this is the first time we see the current .psql file is must be loaded.
    if (!isset($this->myCurrentOldMetadata)) return true;

    // If the .psql has changed the current .psql file is must be loaded.
    if ($this->myCurrentOldMetadata['timestamp']!=$this->myCurrentMtime) return true;

    // Get the old replace pairs
    $old_replace_pairs = unserialize( $this->myCurrentOldMetadata['replace'] );
    if ($old_replace_pairs===false)
    {
      set_assert_failed( "Unable to unserialize replcae pairs for stored routine '%s'.", $this->myCurrentRoutineName );
    }

    // If the value of placeholder has changed the current .psql file is must be loaded.
    foreach( $old_replace_pairs as $place_holder => $old_value )
    {
      if (!isset($this->myReplacePairs[strtoupper( $place_holder )]) ||
           $this->myReplacePairs[strtoupper( $place_holder )]!==$old_value) return true;
    }

    // If current routine is not exist in database .psql file is must be loaded.
    if (!isset($this->myOldRoutines[$this->myCurrentRoutineName])) return true;

    // If current sql-mode different to set in current routine, .psql file is must reload.
    if ($this->myOldRoutines[$this->myCurrentRoutineName]['sql_mode']!=$this->mySqlMode) return true;

    // If current character different to set in current routine, .psql file is must reload.
    if ($this->myOldRoutines[$this->myCurrentRoutineName]['character_set_client']!=$this->myCharacterSet) return true;

    // If current collation different to set in current routine, .psql file is must reload.
    if ($this->myOldRoutines[$this->myCurrentRoutineName]['collation_connection']!=$this->myCollate) return true;


    return false;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Loads the stored routine in file @c myCurrentPsqlFileName into MySQL.
      Returns @c true on success, @c false otherwise.
   */
  private function LoadPsqlFile()
  {
    $this->myCurrentRoutineName         = null;
    $this->myCurrentPsqlSourceCode      = null;
    $this->myCurrentPsqlSourceCodeLines = null;
    $this->myCurrentPlaceholders        = null;
    $this->myCurrentType                = null;
    $this->myCurrentRoutineType         = null;
    $this->myCurrentRoutineName         = null;
    $this->myCurrentColumns             = null;
    $this->myCurrentMtime               = null;
    $this->myCurrentReplace             = array();

    try
    {
      // We assume that the basename of the .psql file and routine name are equal.
      $this->myCurrentRoutineName = basename( $this->myCurrentPsqlFileName, '.psql' );

      // Save old metadata.
      $this->myCurrentOldMetadata = (isset($this->myMetadata[$this->myCurrentRoutineName]))
      ? $this->myMetadata[$this->myCurrentRoutineName]
      : null;

      // Get mtime of the source file.
      $this->myCurrentMtime = filemtime( $this->myCurrentPsqlFileName );
      if ($this->myCurrentMtime===false) set_assert_failed( "Unable to get mtime of file '%s'.",
                                                            $this->myCurrentPsqlFileName );

      // Load the stored routine into MySQL only if the source has changed or the value of a placeholder.
      $load = $this->GetCurrentMustReload();
      if ($load)
      {
        // Read the psql source code.
        $this->myCurrentPsqlSourceCode = file_get_contents( $this->myCurrentPsqlFileName );
        if ($this->myCurrentPsqlSourceCode===false)
        {
          set_assert_failed( "Unable to read file '%s'.", $this->myCurrentPsqlFileName );
        }

        // Split the psql source code into lines.
        $this->myCurrentPsqlSourceCodeLines =  explode( "\n", $this->myCurrentPsqlSourceCode );
        if ($this->myCurrentPsqlSourceCodeLines===false) return false;

        // Extract placeholders from the psql source code.
        $ok = $this->GetCurrentPlaceholders( $this->myCurrentPsqlSourceCode, $this->myCurrentPsqlFileName );
        if ($ok===false) return false;

        // Extract the designation type and key or index columns from the psql source code.
        $ok = $this->GetCurrentType();
        if ($ok===false) return false;

        // Extract the routine type (procedure or function) and routine name from the psql source code.
        $ok = $this->GetCurrentName();
        if ($ok===false) return false;

        // Load the routine into MySQL.
        $this->LoadCurrentPsqlFile();

        // Update curent Metadata;
        $this->UpdateCurentMetadata();
      }

      return true;
    }
    catch (Exception $e)
    {
      echo $e->getMessage();

      $this->myErrorFileNames[] = $this->myCurrentPsqlFileName;

      return false;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Selects schema, table, and colum names and the column type from the MySQL and the column type placeholders
      to @c myReplacePairs.
   */
  private function GetColumnTypes()
  {
    $query = file_get_contents( $this->mySqlColumnTypeFileName );
    if ($query===false) set_assert_failed( "Unable to read file '%s'.", $this->mySqlColumnTypeFileName );

    $rows = SET_DL::ExecuteRows( $query );

    foreach( $rows as $row )
    {
      $key = '@';
      if (isset($row['table_schema'])) $key .= $row['table_schema'].'.';
      $key .= $row['table_name'].'.'.$row['column_name'].'%type@';
      $key = strtoupper( $key );

      $value = $row['column_type'];
      if (isset($row['character_set_name'])) $value .= ' character set '.$row['character_set_name'];

      $this->myReplacePairs[$key] = $value;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Update metadata for current .psql if it exist, otherwise drop current metadata.
   */
  private function UpdateCurentMetadata()
  {
    $query  = sprintf( "
select group_concat( t2.data_type order by t2.ordinal_position separator ',' ) 'arguments'
from            information_schema.ROUTINES   t1
left outer join information_schema.PARAMETERS t2  on  t2.specific_schema = t1.routine_schema and
                                                      t2.specific_name   = t1.routine_name
where t1.routine_schema = database()
and   t1.routine_name   = '%s'", $this->myCurrentRoutineName );

    $tmp = SET_DL::ExecuteRows( $query );  /** @todo replace with execute singleton */
    $argument_types = $tmp[0]['arguments'];

    $this->myMetadata[$this->myCurrentRoutineName]['routine_name']   = $this->myCurrentRoutineName;
    $this->myMetadata[$this->myCurrentRoutineName]['type']           = $this->myCurrentType;
    $this->myMetadata[$this->myCurrentRoutineName]['argument_types'] = $argument_types;
    $this->myMetadata[$this->myCurrentRoutineName]['columns']        = $this->myCurrentColumns;
    $this->myMetadata[$this->myCurrentRoutineName]['timestamp']      = $this->myCurrentMtime;
    $this->myMetadata[$this->myCurrentRoutineName]['replace']        = serialize( $this->myCurrentReplace );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Remove obsolete entries from metadata.
   */
  private function RemoveObsoleteMetadata()
  {
    foreach ( $this->myPsqlFileNames as $myPsqlFileName )
    {
      $tmp = basename( $myPsqlFileName, '.psql' );
      if (isset($this->myMetadata[$tmp])) $clen[$tmp] = $this->myMetadata[$tmp];
    }
    $this->myMetadata = $clen;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get information about all stored routinesin MySQL.
   */
  private function GetOldRoutines()
  {
    $query = "
select routine_name
,      routine_type
,      sql_mode
,      character_set_client
,      collation_connection
from  information_schema.ROUTINES
where ROUTINE_SCHEMA = database()
order by routine_name";

    $rows = SET_DL::ExecuteRows( $query );

    $this->myOldRoutines = array();
    foreach( $rows as $row )
    {
      $this->myOldRoutines[$row['routine_name']] = $row;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Gets real sql mode.
   */
  private function GetCorrectSqlMode()
  {
    $sql = sprintf( "set sql_mode ='%s'", $this->mySqlMode );
    SET_DL::ExecuteNone( $sql );

    $query = "select @@sql_mode;";
    $tmp = SET_DL::ExecuteRows( $query );
    $this->mySqlMode = $tmp[0]['@@sql_mode'];
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Drop obsolete routines (i.e. routines that exits in MySQL but for which we don't have a source file).
   */
  private function DropObsoleteRoutines()
  {
    foreach( $this->myOldRoutines as $old_routine )
    {
      if (!isset($this->myPsqlFileNames[$old_routine['routine_name']]))
      {
        echo sprintf( "Dropping %s %s\n",
                      strtolower( $old_routine['routine_type'] ),
                      $old_routine['routine_name'] );

        $sql = sprintf( "drop %s if exists %s", $old_routine['routine_type'], $old_routine['routine_name'] );
        SET_DL::ExecuteNone( $sql );
      }
    }
  }


  //--------------------------------------------------------------------------------------------------------------------
  /** Get all .psql into $this->myPsqlFileNames file from list.
   */
  private function GetPsqlFileName( $theFilenames )
  {
    foreach( $theFilenames as $psql_file_name )
    {
      if (file_exists( $psql_file_name ))
      {
        $base_name = basename( $psql_file_name, '.psql' );
        if (!isset($this->myPsqlFileNames[$base_name]))
        {
          $this->myPsqlFileNames[$base_name] = $psql_file_name;
        }
        else
        {
          echo sprintf( "Error: Files '%s' and '%s' have the same basename.\n",
                        $this->myPsqlFileNames[$base_name],
                        $psql_file_name );
          $this->myErrorFileNames[] = $psql_file_name;
        }
      }
      else
      {
        echo sprintf( " Not correct set name file or file not exists: '%s'.\n", $psql_file_name);
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get all .psql file from source directory and processed their.
   */
  private function LoadAll( $theConfigFileName )
  {
    $this->ReadConfigFile( $theConfigFileName );

    SET_DL::Connect( $this->myHostName, $this->myUserName, $this->myPassWord, $this->myDatabase );

    $this->FindPsqlFiles();
    $this->GetColumnTypes();
    $this->ReadRoutineMetaData();
    $this->GetConstants();
    $this->GetOldRoutines();
    $this->GetCorrectSqlMode();

    foreach( $this->myPsqlFileNames as $this->myCurrentPsqlFileName )
    {
      $err = $this->LoadPsqlFile();
      if ($err===false)
      {
        $this->myErrorFileNames = $this->myCurrentPsqlFileName;
        unset($this->myMetadata[$this->myCurrentRoutineName]);
      }
    }

    // Drop obsolete routines.
    $this->DropObsoleteRoutines();

    // Remove metadata of store routines that have been removed.
    $this->RemoveObsoleteMetadata();

    // Write the metadata to @c $myMetadataFileName.
    $this->WriteRoutineMetadata();

    SET_DL::Disconnect();
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Get all .psql file from list set in command line and processed their.
   */
  private function LoadList( $theConfigFileName, $theFilenames )
  {
    $this->ReadConfigFile( $theConfigFileName );

    SET_DL::Connect( $this->myHostName, $this->myUserName, $this->myPassWord, $this->myDatabase );

    $this->GetPsqlFileName( $theFilenames );
    $this->GetColumnTypes();
    $this->ReadRoutineMetaData();
    $this->GetConstants();
    $this->GetOldRoutines();
    $this->GetCorrectSqlMode();

    foreach( $this->myPsqlFileNames as $this->myCurrentPsqlFileName )
    {
      $err = $this->LoadPsqlFile();
      if ($err===false)
      {
        $this->myErrorFileNames = $this->myCurrentPsqlFileName;
        unset($this->myMetadata[$this->myCurrentRoutineName]);
      }
    }

    // Write the metadata to @c $myMetadataFileName.
    $this->WriteRoutineMetadata();

    SET_DL::Disconnect();
  }

  //--------------------------------------------------------------------------------------------------------------------
  public function Run( $theConfigFileName, $theFilenames )
  {
    if (empty($theFilenames))
    {
      $this->LoadAll( $theConfigFileName );
    }
    else
    {
      $this->LoadList( $theConfigFileName, $theFilenames );
    }
    return 0;
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief abstract supper class for generation stored routine wrapper methods based on the type of the stored routine.
 */
abstract class SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** The constant contain width page (in chars).
   */
  const C_PAGE_WIDTH = 120;

  /** The current level of indentation in the generated code.
   */
  private $myIndentLevel = 1;

  /** Buffer for generated code.
   */
  private $myCode = '';

  //--------------------------------------------------------------------------------------------------------------------
  /** Appends @a $theString to @c $myCode.
   */
  protected function Write( $theString )
  {
    $this->myCode .= $theString;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Appends @a $theString and a LF to @c $myCode.
      - @a $theString must not contain a LF.
      - Indent level is increased or decreased as @a $theString equals to '{' or '}'.
   */
  protected function WriteLine( $theString=false )
  {
    if ($theString)
    {
      if (trim($theString)=='}') $this->myIndentLevel--;
      for( $i=0; $i<2*$this->myIndentLevel; $i++ )
      {
        $this->Write( ' ' );
      }
      $this->myCode .= $theString;
      $this->myCode .= "\n";
      if (trim($theString)=='{') $this->myIndentLevel++;
    }
    else
    {
      $this->myCode .= "\n";
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Appends a comment line to @c $myCode.
   */
  protected function WriteSeparator()
  {
    for( $i=0; $i<2*$this->myIndentLevel; $i++ )
    {
      $this->Write( ' ' );
    }

    $this->Write( '//' );

    for( $i=0; $i<(self::C_PAGE_WIDTH-2*$this->myIndentLevel-2-1); $i++ )
    {
      $this->Write( '-' );
    }
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns @a $theSqlFunctionName after the first underscore in camel case.
      E.g. set_foo_foo => FooFoo.
   */
  private function GetWrapperRoutineName( $theSqlFunctionName )
  {
    $name = preg_replace( '/(_)([a-z])/e', "strtoupper('\\2')", stristr( $theSqlFunctionName, '_' ) );

    return $name;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for escaping the arguments of a stored routine.
      @param $theArgsTypes An array with the arguments of a strored routine.
   */
  private function WriteEscapedArgs( $theArgType, $numberArgType )
  {
    switch ($theArgType)
    {
    case 'tinyint':
    case 'smallint':
    case 'mediumint':
    case 'int':
    case 'bigint':

    case 'year':

    case 'decimal':
    case 'float':
    case 'double':
      $ret = '\'.self::QuoteNum($theArg'.$numberArgType.').\'';
      break;

    case 'varbinary':
    case 'binary':

    case 'char':
    case 'varchar':
      $ret = '\'.self::QuoteString($theArg'.$numberArgType.').\'';
      break;

    case 'time':
    case 'timestamp':

    case 'date':
    case 'datetime':
      $ret = '\'.self::QuoteString($theArg'.$numberArgType.').\'';
      break;

    case 'enum':
    case 'set':
      $ret = '\'.self::QuoteString($theArg'.$numberArgType.').\'';
      break;

    case 'bit':
      $ret = '\'.self::QuoteBit($theArg'.$numberArgType.').\'';
      break;

    case 'tinytext':
    case 'text':
    case 'mediumtext':
    case 'longtext':

    case 'tinyblob':
    case 'blob':
    case 'mediumblob':
    case 'longblob':
      $ret = '?';
      break;

    default:
      set_assert_failed( "Unknown arg type '%s'.", $theArgType );
    }

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for the arguments of the wrapper method for @a $theRoutine.
      @param $theRoutine An arry with the argument types of the stored routine.
   */
  private function GetWrapperArgs( $theRoutine )
  {
    if ($theRoutine['argument_types']) $argument_types = explode( ',', $theRoutine['argument_types'] );
    else                               $argument_types = array();

    if ($theRoutine['type']=='bulk') $ret = '$theBulkHandler';
    else                             $ret = '';

    foreach( $argument_types as $i => $arg_type )
    {
      if ($ret) $ret .= ',';
      switch ($arg_type)
      {
      case 'tinyint':
      case 'smallint':
      case 'mediumint':
      case 'int':
      case 'bigint':

      case 'year':

      case 'decimal':
      case 'float':
      case 'double':
        $ret .= '$theArg'.$i;
        break;

      case 'varbinary':
      case 'binary':

      case 'char':
      case 'varchar':
        $ret .= '$theArg'.$i;
        break;

      case 'time':
      case 'timestamp':

      case 'date':
      case 'datetime':
        $ret .= '$theArg'.$i;
        break;

      case 'enum':
      case 'bit':
      case 'set':
        $ret .= '$theArg'.$i;
        break;

      case 'tinytext':
      case 'text':
      case 'mediumtext':
      case 'longtext':
        $ret .= '$theArg'.$i;
        break;

      case 'tinyblob':
      case 'blob':
      case 'mediumblob':
      case 'longblob':
        $ret .= '$theArg'.$i;
        break;

      default:
        set_assert_failed( "Unknown arg type '$arg_type'." );
      }
    }

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for the arguments for calling the stored routine in a wrapper method.
      @param $theArgsTypes array with the argument type of a Stored Routine.
   */
  protected function GetRoutineArgs( $theArgsTypes )
  {
    $ret = '';
    foreach( $theArgsTypes as $i => $arg_type )
    {
      if ($ret) $ret .= ',';
      $ret .= $this->WriteEscapedArgs( $arg_type, $i );
    }

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for the arguments for calling the stored routine in a wrapper method.
      @param $theType array with the argument type of a Stored Routine.
   */
  protected function GetTypeForLob( $theType )
  {
    $ret = '';
    switch ($theType)
    {
    case 'tinyint':
    case 'smallint':
    case 'mediumint':
    case 'int':
    case 'bigint':
    case 'year':
      $ret = 'i';
      break;

    case 'decimal':
    case 'float':
    case 'double':
      $ret = 'd';
      break;


    case 'time':
    case 'timestamp':
    case 'binary':
    case 'enum':
    case 'bit':
    case 'set':
    case 'char':
    case 'varchar':
    case 'date':
    case 'datetime':
    case 'varbinary':
      $ret = 's';
      break;

    case 'tinytext':
    case 'text':
    case 'mediumtext':
    case 'longtext':
    case 'tinyblob':
    case 'blob':
    case 'mediumblob':
    case 'longblob':
      $ret .= 'b';
      break;

    default:
          set_assert_failed( "Unknown type '%s'.", $theType );
    }

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Genereert een volledige wrapper methode voor een Stored Routine.
      @param $theRoutine Een rij uit tabel DEV_ROUTINE.
   */
  public function WriteRoutineFunctionWithoutLob( $theRoutine )
  {
    if ($theRoutine['argument_types']) $argument_types = explode( ',', $theRoutine['argument_types'] );
    else                               $argument_types = array();

    $wrapper_function_name = $this->GetWrapperRoutineName( $theRoutine['routine_name'] );
    $wrapper_args          = $this->GetWrapperArgs( $theRoutine );

    $this->WriteSeparator();
    $this->WriteLine( '/** @sa Stored Routine '.$theRoutine['routine_name'].'.' );
    $this->WriteLine( ' */' );
    $this->WriteLine( 'static function '.$wrapper_function_name.'('.$wrapper_args.')' );
    $this->WriteLine( '{' );

    $this->WriteResultHandler( $theRoutine, $argument_types );
    $this->WriteLine( '}' );
    $this->WriteLine();

    return $this->myCode;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates a complete wrapper method.
      @param $theRoutine Metadata of the stored routine.
   */
  public function WriteRoutineFunctionWithLob( $theRoutine )
  {
    if ($theRoutine['argument_types']) $argument_types = explode( ',', $theRoutine['argument_types'] );
    else                               $argument_types = array();

    $wrapper_function_name = $this->GetWrapperRoutineName( $theRoutine['routine_name'] );
    $wrapper_args          = $this->GetWrapperArgs( $theRoutine );
    $routine_args          = $this->GetRoutineArgs( $argument_types );

    $types = '';
    $nulls = '';
    foreach( $argument_types as $theType )
    {
      $type = $this->GetTypeForLob( $theType );
      if ($type=='b')
      {
        $types .= 'b';
        if ($nulls) $nulls .= ',';
        $nulls .= '$null';
      }
    }

    $this->WriteSeparator();
    $this->WriteLine( '/** @sa Stored Routine '.$theRoutine['routine_name'].'.' );
    $this->WriteLine( ' */' );
    $this->WriteLine( 'static function '.$wrapper_function_name.'('.$wrapper_args.')' );
    $this->WriteLine( '{' );
    $this->Writeline( '$query = \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\';' );
    $this->Writeline( '$stmt  = self::$ourMySql->prepare( $query );' );
    $this->Writeline( 'if (!$stmt) self::ThrowSqlError( \'prepare failed\' );' );
    $this->WriteLine();
    $this->WriteLine( '$null = null;' );
    $this->Writeline( '$b = $stmt->bind_param( \''.$types.'\', '.$nulls.' );' );
    $this->Writeline( 'if (!$b) self::ThrowSqlError( \'bind_param failed\' );' );
    $this->WriteLine();

    $blob_argument_index = 0;
    foreach( $argument_types as $i => $argument )
    {
      if ($this->GetTypeForLob( $argument )=='b')
      {
        $this->Writeline( '$n = strlen( $theArg'.$i.' );' );
        $this->Writeline( '$p = 0;' );
        $this->Writeline( 'while ($p<$n)' );
        $this->Writeline( '{' );
        $this->Writeline( '$b = $stmt->send_long_data( '.$blob_argument_index.', substr( $theArg'.$i.', $p, self::$ourChunckSize ) );' );
        $this->Writeline( 'if (!$b) self::ThrowSqlError( \'send_long_data failed\' );' );
        $this->Writeline( '$p += self::$ourChunckSize;' );
        $this->Writeline( '}' );
        $this->WriteLine();

        $blob_argument_index++;
      }
    }

    $this->Writeline( '$b = $stmt->execute();' );
    $this->Writeline( 'if (!$b) self::ThrowSqlError( \'execute failed\' );' );
    $this->WriteLine();
    $this->WriteRoutineFunctionLobFetchData( $theRoutine );
    $this->Writeline( '$stmt->close();' );
    $this->Writeline( 'self::$ourMySql->next_result();' );
    $this->WriteLine();
    $this->WriteRoutineFunctionLobReturnData();
    $this->WriteLine( '}' );
    $this->WriteLine();

    return $this->myCode;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns @c true if one of the arguments is a BLOB or CLOB.
      @param $theArgumentsType An aaray with the argument types.
   */
  public function IsBlobArgument( $theArgumentsType )
  {
    $has_blob = false;
    foreach( $theArgumentsType as $argument_type )
    {
      switch ($argument_type)
      {
      case 'tinytext':
      case 'text':
      case 'mediumtext':
      case 'longtext':

      case 'tinyblob':
      case 'blob':
      case 'mediumblob':
      case 'longblob':

        $has_blob = true;
        break;
      }
    }

    return $has_blob;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates a complete wrapper method.
      @param $theRoutine Metadata of the stored routine.
   */
  public function WriteRoutineFunction( $theRoutine )
  {
    $theArgumentsType = explode( ',', $theRoutine['argument_types'] );

    $has_blob = $this->IsBlobArgument( $theArgumentsType );

    if ($has_blob==true)
    {
      return $this->WriteRoutineFunctionWithLob( $theRoutine );
    }
    else
    {
      return $this->WriteRoutineFunctionWithoutLob( $theRoutine );
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  abstract protected function WriteResultHandler( $theRoutine, $theArgumentTypes );

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for fetching data of a stored routine with one or more LOB arguments.
      @todo Make abstract and implement for all child classes
   */
  abstract protected function WriteRoutineFunctionLobFetchData( $theRoutine );

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for returing the data returend by a stored routine with one or more LOB arguments.
      @todo Make abstract and implement for all child classes
   */
  abstract protected function WriteRoutineFunctionLobReturnData();

  //--------------------------------------------------------------------------------------------------------------------
  /** A factory for creating the appropiate object for generating code for the stored routine @a $theRoutine.
   */
  static public function CreateRoutineWrapper( $theRoutine )
  {
    switch ($theRoutine['type'])
    {
    case 'bulk':
      $class = 'SET_RoutineWrapperBulk';
      break;

    case 'log':
      $class = 'SET_RoutineWrapperLog';
      break;

    case 'none':
      $class = 'SET_RoutineWrapperNone';
      break;

    case 'row0':
      $class = 'SET_RoutineWrapperRow0';
      break;

    case 'row1':
      $class = 'SET_RoutineWrapperRow1';
      break;

    case 'rows':
      $class = 'SET_RoutineWrapperRows';
      break;

    case 'rows_with_key':
      $class = 'SET_RoutineWrapperRowsWithKey';
      break;

    case 'rows_with_index':
      $class = 'SET_RoutineWrapperRowsWithIndex';
      break;

    case 'singleton0':
      $class = 'SET_RoutineWrapperSingleton0';
      break;

    case 'singleton1':
      $class = 'SET_RoutineWrapperSingleton1';
      break;

    default:
      set_assert_failed( "Unknown routine type '%s'.", $theRoutine['columns'] );
    }

    $wrapper = new $class();

    return $wrapper;
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that uses for large volumes of data.
 */
class SET_RoutineWrapperBulk extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'self::ExecuteBulk( $theBulkHandler, \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    // Nothing todo.
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    // Nothing todo.
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that returns nothing but writes the rows of
 *  the results sets to the standard out.
 */
class SET_RoutineWrapperLog extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
     @param $theRoutine       An array with the metadata of the stored routine.
     @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'self::ExecuteEcho( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\' );' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    // Nothing todo.
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    // Nothing todo.
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that doesn't return anything.
 */
class SET_RoutineWrapperNone extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'return self::ExecuteNone( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\' );' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $this->WriteLine( '$ret = self::$ourMySql->affected_rows;' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    $this->WriteLine( 'return $ret;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that selects 0 or 1 rows.
 */
class SET_RoutineWrapperRow0 extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'return self::ExecuteRow0( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );

    /** @todo Test the actual number of rows and number  use result->num_rows*/
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $this->WriteLine( '$row = array();' );
    $this->WriteLine( 'self::stmt_bind_assoc( $stmt, $row );' );
    $this->WriteLine();
    $this->WriteLine( '$tmp = array();' );
    $this->WriteLine( 'while (($b = $stmt->fetch()))' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new = array();' );
    $this->WriteLine( 'foreach( $row as $key => $value )' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new[$key] = $value;' );
    $this->WriteLine( '}' );
    $this->WriteLine( '$tmp[] = $new;' );
    $this->WriteLine( '}' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    $this->WriteLine( 'if ($b===false) self::ThrowSqlError( \'mysqli_stmt::fetch failed\' );' );
    $this->WriteLine( 'if (sizeof($tmp)>1) self::ThrowSqlError( \'The unexpected number of rows, expected 0 or 1 rows.\' );' );
    $this->WriteLine();
    $this->WriteLine( 'return ($tmp) ? $tmp[0] : null;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that selects 1 and only 1 rows.
 */
class SET_RoutineWrapperRow1 extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'return self::ExecuteRow1( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $this->WriteLine( '$row = array();' );
    $this->WriteLine( 'self::stmt_bind_assoc( $stmt, $row );' );
    $this->WriteLine();
    $this->WriteLine( '$tmp = array();' );
    $this->WriteLine( 'while (($b = $stmt->fetch()))' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new = array();' );
    $this->WriteLine( 'foreach( $row as $key => $value )' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new[$key] = $value;' );
    $this->WriteLine( '}' );
    $this->WriteLine( '$tmp[] = $new;' );
    $this->WriteLine( '}' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    $this->WriteLine( 'if ($b===false) self::ThrowSqlError( \'mysqli_stmt::fetch failed\' );' );
    $this->WriteLine( 'if (sizeof($tmp)!=1) self::ThrowSqlError( \'The unexpected  number of rows,  expected 1 row.\' );' );
    $this->WriteLine();
    $this->WriteLine( 'return $row;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that selects 0 or more rows.
 */
class SET_RoutineWrapperRows extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'return self::ExecuteRows( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $this->WriteLine( '$row = array();' );
    $this->WriteLine( 'self::stmt_bind_assoc( $stmt, $row );' );
    $this->WriteLine();
    $this->WriteLine( '$tmp = array();' );
    $this->WriteLine( 'while (($b = $stmt->fetch()))' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new = array();' );
    $this->WriteLine( 'foreach( $row as $key => $value )' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new[$key] = $value;' );
    $this->WriteLine( '}' );
    $this->WriteLine( ' $tmp[] = $new;' );
    $this->WriteLine( '}' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    $this->WriteLine( 'if ($b===false) self::ThrowSqlError( \'mysqli_stmt::fetch failed\' );' );
    $this->WriteLine();
    $this->WriteLine( 'return $tmp;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that selects rows on keys.
 */
class SET_RoutineWrapperRowsWithKey extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $key = '';
    foreach( $theRoutine['columns'] as $column ) $key .= '[$row[\''.$column.'\']]';

    $this->WriteLine( '$result = self::Query( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );
    $this->WriteLine( '$ret = array();' );
    $this->WriteLine( 'while($row = $result->fetch_array( MYSQLI_ASSOC )) $ret'.$key.' = $row;' );
    $this->WriteLine( '$result->close();' );
    $this->WriteLine( 'self::$ourMySql->next_result();' );
    $this->WriteLine( 'return  $ret;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $key = '';
    foreach( $theRoutine['columns'] as $column ) $key .= '[$new[\''.$column.'\']]';

    $this->Writeline( '$row = array();' );
    $this->Writeline( 'self::stmt_bind_assoc( $stmt, $row );' );
    $this->Writeline();
    $this->Writeline( '$ret = array();' );
    $this->Writeline( 'while (($b = $stmt->fetch()))' );
    $this->Writeline( '{' );
    $this->Writeline( '$new = array();' );
    $this->Writeline( 'foreach( $row as $key => $value )' );
    $this->Writeline( '{' );
    $this->Writeline( '$new[$key] = $value;' );
    $this->Writeline( '}' );
    $this->Writeline( '$ret'.$key.' = $new;' );
    $this->WriteLine( '}' );
    $this->WriteLine();
    $this->Writeline( '$b = $stmt->fetch();' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    $this->Writeline( 'if ($b===false) self::ThrowSqlError( \'mysqli_stmt::fetch failed\' );' );
    $this->WriteLine();
    $this->WriteLine( 'return $ret;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that selects rows on index.
 */
class SET_RoutineWrapperRowsWithIndex extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $index = '';
    foreach( $theRoutine['columns'] as $column ) $index .= '[$row[\''.$column.'\']]';

    $this->WriteLine( '$result = self::Query( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );
    $this->WriteLine( '$ret = array();' );
    $this->WriteLine( 'while($row = $result->fetch_array( MYSQLI_ASSOC )) $ret'.$index.'[] = $row;' );
    $this->WriteLine( '$result->close();' );
    $this->WriteLine( 'self::$ourMySql->next_result();' );
    $this->WriteLine( 'return $ret;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $index = '';
    foreach( $theRoutine['columns'] as $column ) $index .= '[$new[\''.$column.'\']]';

    $this->Writeline( '$row = array();' );
    $this->Writeline( 'self::stmt_bind_assoc( $stmt, $row );' );
    $this->Writeline();
    $this->Writeline( '$ret = array();' );
    $this->Writeline( 'while (($b = $stmt->fetch()))' );
    $this->Writeline( '{' );
    $this->Writeline( '$new = array();' );
    $this->Writeline( 'foreach( $row as $key => $value )' );
    $this->Writeline( '{' );
    $this->Writeline( '$new[$key] = $value;' );
    $this->Writeline( '}' );
    $this->Writeline( '$ret'.$index.'[] = $new;' );
    $this->WriteLine( '}' );
    $this->WriteLine();
    $this->Writeline( '$b = $stmt->fetch();' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {

    $this->Writeline( 'if ($b===false) self::ThrowSqlError( \'mysqli_stmt::fetch failed\' );' );
    $this->WriteLine();
    $this->WriteLine( 'return $ret;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that returns a scalar or 0.
 */
class SET_RoutineWrapperSingleton0 extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'return self::ExecuteSingleton0( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $this->Writeline( '$row = array();' );
    $this->Writeline( 'self::stmt_bind_assoc( $stmt, $row );' );
    $this->WriteLine();
    $this->WriteLine( '$tmp = array();' );
    $this->WriteLine( 'while (($b = $stmt->fetch()))' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new = array();' );
    $this->WriteLine( 'foreach( $row as $value )' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new[] = $value;' );
    $this->WriteLine( '}' );
    $this->WriteLine( '$tmp[] = $new;' );
    $this->WriteLine( '}' );
    $this->WriteLine();
    $this->Writeline( '$b = $stmt->fetch();' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    $this->Writeline( 'if ($b===false) self::ThrowSqlError( \'mysqli_stmt::fetch failed\' );' );
    $this->WriteLine( 'if (sizeof($tmp)>1) self::ThrowSqlError( \'The unexpected number of rows, expected 0 or 1 rows.\' );');
    $this->WriteLine();
    $this->WriteLine( 'return ($tmp) ? $tmp[0][0] : null;' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}


//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for generating a wrapper function around a stored procedure that returns a scalar.
 */
class SET_RoutineWrapperSingleton1 extends SET_RoutineWrapper_abstract
{
  //--------------------------------------------------------------------------------------------------------------------
  /** Generates code for calling the stored routine in the wrapper method.
      @param $theRoutine       An array with the metadata of the stored routine.
      @param $theArgumentTypes An array with the arguments types of the stored routine.
   */
  protected function WriteResultHandler( $theRoutine, $theArgumentTypes )
  {
    $routine_args = $this->GetRoutineArgs( $theArgumentTypes );
    $this->WriteLine( 'return self::ExecuteSingleton1( \'CALL '.$theRoutine['routine_name'].'('.$routine_args.')\');' );
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobFetchData( $theRoutine )
  {
    $this->Writeline( '$row = array();' );
    $this->Writeline( 'self::stmt_bind_assoc( $stmt, $row );' );
    $this->WriteLine();
    $this->WriteLine( '$tmp = array();' );
    $this->WriteLine( 'while (($b = $stmt->fetch()))' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new = array();' );
    $this->WriteLine( 'foreach( $row as $value )' );
    $this->WriteLine( '{' );
    $this->WriteLine( '$new[] = $value;' );
    $this->WriteLine( '}' );
    $this->WriteLine( '$tmp[] = $new;' );
    $this->WriteLine( '}' );
    $this->WriteLine();
    $this->Writeline( '$b = $stmt->fetch();' );
    $this->WriteLine();
  }

  //--------------------------------------------------------------------------------------------------------------------
  protected function WriteRoutineFunctionLobReturnData()
  {
    $this->Writeline( 'if ($b===false) self::ThrowSqlError( \'mysqli_stmt::fetch failed\' );' );
    $this->WriteLine( 'if (sizeof($tmp)!=1) self::ThrowSqlError( \'The unexpected number of rows, expected 1 row.\' );' );
    $this->WriteLine();
    $this->WriteLine( 'return $tmp[0][0];' );
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Klasse voor een programma voor het aanmaken aan een klasse met wrappers functies voor Stored Routines in het
    SET schema.
 */
class SET_RoutineWrapper
{
  /** Processed code function.
   */
  private $myCode = '' ;

  /** The filename of the template.
   */
  private $myTemplateFileName;

  /** The filename where the generated wrapper class must be stored
   */
  private $myWrapperFileName;

  /** The filename of the file with the metadata of all stored procedures.
   */
  private $myMetadataFilename;

  /** The filename of the configuration file.
   */
  private $myConfigurationFileName;

  //--------------------------------------------------------------------------------------------------------------------
  /** Generates a complete wrapper method for a Stored Routine.
   пїЅ  @param $theRoutine The row from table DEV_ROUTINE.
   */
  private function WriteRoutineFunction( $theRoutine )
  {
    $wrapper = SET_RoutineWrapper_abstract::CreateRoutineWrapper( $theRoutine );

    $this->myCode .= $wrapper->WriteRoutineFunction( $theRoutine );
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns the metadata @a $routines of stored routines stored in file.
   */
  private function ReadRoutineMetaData()
  {
    $theFileName = $this->myMetadataFilename;

    $handle = fopen( $theFileName, 'r' );
    if ($handle===null) set_assert_failed( "Unable to open file '%s'.", $theFileName );

    // Skip header row.
    fgetcsv( $handle, 1000, ',' );
    $line_number = 1;

    while (($row = fgetcsv( $handle, 1000, ',' ))!==false)
    {
      $line_number++;

      // Test the number of fields in the row.
      $n = sizeof( $row );
      if ($n!=6)
      {
        set_assert_failed( "Error at line %d in file '%s'. Expecting %d fields but found %d fields.",
                           $line_number,
                           $theFileName,
                           6,
                           $n );
      }

      $routines[] = array( 'routine_name'   => $row[0],
                           'type'           => $row[1],
                           'argument_types' => $row[2],
                           'columns'        => explode( ',', $row[3] ) );
    }

    $err = fclose( $handle );
    if ($err===false) set_assert_failed( "Error closing file '%s'.", $theFileName );

    return $routines;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Getting parameters from a array @a $theSettings whit key @c $theSectionName and @c $theSettingName.
   */
  private function GetSetting( $theSettings, $theSectionName, $theSettingName )
  {
    // Test if the section exists.
    if (!array_key_exists( $theSectionName, $theSettings ))
    {
      set_assert_failed( "Section '%s' not found in configuration file '%s'.",
                         $theSectionName,
                         $this->myConfigurationFileName );
    }

    // Test if the setting in the section exists.
    if (!array_key_exists( $theSettingName, $theSettings[$theSectionName] ))
    {
      set_assert_failed( "Setting '%s' not found in section '%s' configuration file '%s'.",
                         $theSettingName,
                         $theSectionName,
                         $this->myConfigurationFileName );
    }

    return $theSettings[$theSectionName][$theSettingName];
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Read parameters from the configuration file @c $myConfigurationFileName.
   */
  private function ReadConfigurationFile()
  {
    $settings = parse_ini_file( $this->myConfigurationFileName, true );
    if ($settings===false) set_assert_failed( "Unable open configuration file '%s'", $this->myConfigurationFileName );

    $this->myTemplateFileName = $this->GetSetting( $settings, 'wrapper', 'template' );
    $this->myWrapperFileName  = $this->GetSetting( $settings, 'wrapper', 'wrapper' );
    $this->myMetadataFilename = $this->GetSetting( $settings, 'wrapper', 'metadata');
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Construction class for stored routine wrapper.
      @param $ConfigurationFileName The path file configuration.
   */
  public function Run( $ConfigurationFileName )
  {
    $this->myConfigurationFileName = $ConfigurationFileName;

    $this->ReadConfigurationFile();

    $routines = $this->ReadRoutineMetaData();

    foreach( $routines as $routine )
    {
      $this->WriteRoutineFunction( $routine );
    }

    $replace['  /* AUTO_GENERATED_ROUINE_WRAPPERS */'] =  $this->myCode;

    $code = file_get_contents( $this->myTemplateFileName );
    if ($code===false)
    {
      set_assert_failed("Error reading file %s", $this->myTemplateFileName );
    }

    $code = strtr( $code, $replace );

    $bytes = file_put_contents( $this->myWrapperFileName, $code );
    if ($bytes===false)
    {
      set_assert_failed("Error writing file %s", $this->myWrapperFileName );
    }

    return 0;
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
function Main( $options )
{
  $setting = GetSetting( $options );

  if (isset($setting['fast']))
  {
    // For mode: only load stored routines.
    $loader = new SET_RoutineLoader;
    $ret = $loader->Run( $setting['config'], $setting['psql_files'] );
    if ($ret!=0) exit( $ret );
  }
  else
  {
    // Normal mode: create constants, config file, load routines, and create routine wrapper class.
    $consts = new SET_ConfigConstants;
    $ret = $consts->Run( $setting['config'] );
    if ($ret!=0) exit( $ret );

    $loader = new SET_RoutineLoader;
    $ret = $loader->Run( $setting['config'], $setting['psql_files'] );
    if ($ret!=0) exit( $ret );

    $wrapper = new SET_RoutineWrapper;
    $ret = $wrapper->Run( $setting['config'] );
    if ($ret!=0) exit( $ret );
  }
}

function GetSetting( $options )
{
  // skip first key with current file name.
  array_shift($options);
  $setting['psql_files'] = array();
  while(($param = array_shift($options))!==null )
  {
    switch ($param)
    {
    case '-f':
    case '-fast':
      $setting['fast'] = true;
      break;

    case '-c':
    case '-config':
      $setting['config'] = array_shift($options);
      break;

    case '-h':
    case '-help':
      Synopsis();
      break;

    default:
      $n = preg_match( "([A-Za-z0-9\_/]+.psql)", $param, $regs );
      if (!$n===false)
      {
        $setting['psql_files'][]= $regs[0];
      }
      else Synopsis();
      break;
    }
  }

  if (!isset($setting['config'])) Synopsis();
  return $setting;
}

function Synopsis()
{
  echo "Synopsis: dlgen [-f] -c <configuration file> [routine.psql]... \n";
  echo "          dlgen -h\n";
  exit(1);
}

Main($argv);
