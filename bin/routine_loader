#!/usr/bin/php
<?php
//----------------------------------------------------------------------------------------------------------------------
/** Throws an execption. Arguments similair to printf.
 */
function set_assert_failed()
{
  $args    = func_get_args();
  $format  = array_shift( $args );
  $message = vsprintf( $format,  $args );

  throw new Exception( $message );
}

// ---------------------------------------------------------------------------------------------------------------------
/** @brief Klasse met wrapper functies voor alle stored procedures die aangeroepen mogen worden door PHP-code.
 */
class SET_DL
{
  /** Referentie naar een mysqli object (zie Connect) dat gebruikt wordt voor het afvuren van alle SQL satements in
   *  deze klasse.
   */
  private static $ourMySql;

  // -------------------------------------------------------------------------------------------------------------------
  /** Werpt een excptie met de huidige error code en beschrijving van $ourMySql.
   */
  private static function ThrowSqlError( $theText )
  {
    $message  = "MySQL Error no: ".self::$ourMySql->errno."\n";
    $message .= self::$ourMySql->error;
    $message .= "\n";
    $message .= $theText."\n";

    throw new Exception( $message );
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Wrapper om mysqli::query. Indien de call naar mysqli::query mislukt wordt een een exceptie geworpen.
   */
  private static function Query( $theQuery )
  {
    $ret = self::$ourMySql->query( $theQuery );
    if ($ret===false) self::ThrowSqlError( $theQuery );

    return $ret;
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Wrapper om mysqli::real_query. Indien de call naar mysqli::real_query mislukt wordt een een exceptie geworpen.
   */
  private static function RealQuery( $theQuery )
  {
    $tmp = self::$ourMySql->real_query( $theQuery );
    if ($tmp===false) self::ThrowSqlError( $theQuery );
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Start een transactie in MySQL.
   */
  public static function Begin()
  {
    $ret = self::$ourMySql->autocommit(false);
    if (!$ret) self::ThrowSqlError( 'autocommit' );
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Commit de huidige transactie in MySQL.
   */
  public static function Commit()
  {
    $ret = self::$ourMySql->commit();
    if (!$ret) self::ThrowSqlError( 'commit' );
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Connecteert naar de MySQL server (parameters @a $theHostName, @a $theUserName, @a $thePassWord en @a $theDatabase)
   *  en voert een aantal initialisaties uit.
   */
  public static function Connect( $theHostName, $theUserName, $thePassWord, $theDatabase )
  {
    self::$ourMySql = new mysqli( $theHostName, $theUserName, $thePassWord, $theDatabase );
    if (!self::$ourMySql) self::ThrowSqlError( 'init' );

    $ret = self::$ourMySql->options(MYSQLI_OPT_CONNECT_TIMEOUT, 600);
    if (!$ret) self::ThrowSqlError( 'options' );

    $ret = self::$ourMySql->set_charset("utf8");
    if (!$ret) self::ThrowSqlError( 'set_charset' );
    /*
    $ret = self::ExecuteNone( "set sql_mode = '".SET_SQL_MODE."'");

    // The default transaction level is REPEATABLE-READ. Set transaction level to READ-COMMITED.
    self::ExecuteNone( "SET tx_isolation = 'READ-COMMITTED'" );

    // Disable query caching.
    self::ExecuteNone( "set query_cache_type = 0" );*/
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Indien er een verbinding is met een MySQL server, verbreekt de verbinding.
   */
  public static function Disconnect()
  {
    if (self::$ourMySql)
    {
      self::$ourMySql->close();
      self::$ourMySql = null;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Voert query @a $theQuery uit. @a $theQuery mag 0 of meer rijen teruggeven.
   */
  public function ExecuteRows( $theQuery )
  {
    $result = self::Query( $theQuery );
    $ret = array();
    while($row = $result->fetch_array( MYSQLI_ASSOC )) $ret[] = $row;
    $result->close();

    self::$ourMySql->next_result();

    return $ret;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Voert query @a $theQuery uit een geeft het aantal "affected rows" terug. @a $theQuery mag geen rijen teruggeven.
   */
  public function ExecuteNone( $theQuery )
  {
    self::Query( $theQuery );

    $n = self::$ourMySql->affected_rows;

    self::$ourMySql->next_result();

    return $n;
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Voert query @a $theQuery uit. De query mag een multi query zijn (b.v. een store procedure) en de output van de
   *  query wordt gelogt.
   */
  public static function ExecuteEcho( $theQuery )
  {
    $ret = self::$ourMySql->multi_query( $theQuery );
    if (!$ret) self::ThrowSqlError( $theQuery );
    do
    {
      $result = self::$ourMySql->store_result();
      if (self::$ourMySql->errno) self::ThrowSqlError( '$mysqli->store_result failed for \''.$theQuery.'\'' );
      if ($result)
      {
        $fields = $result->fetch_fields();
        while ($row = $result->fetch_row())
        {
          $line = '';
          foreach( $row as $i => $field )
          {
            if ($i>0) $line .= ' ';
            $line .= str_pad( $field, $fields[$i]->max_length );
          }
          etl_log( $line );
        }
        $result->free();
      }
    }
    while (self::$ourMySql->next_result());
    if (self::$ourMySql->errno) self::ThrowSqlError( '$mysqli->next_result failed for \''.$theQuery.'\'' );
  }

  // -------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
/** @brief Class for loading stored routine into a MySQL instance from pseudo SQL files (.psql).
 */
class SET_RoutineLoader
{
  /** @name Settings
     @{
     Properties for settings.
  */

  /** Path where .psql files can be found.
  */
  private $myIncludePath;

  /** The name of the file with SQL statement to retreive table and column names, and column types.
   */
  private $mySqlColumnTypeFileName;


  /** The name of the configuration file of the target porject
   */
  private $myTargetConfigFileName;
  /** @} */



  /** @name Overall
     @{
     Properties with data about all stored routines and .psql files.
   */

  /** An array with all found .psql files.
   */
  private $myPsqlFileNames = array();


  /** The filename of the file with the metadata of all stored routines.
   */
  private $myMetadataFilename;


  /** Array with the metadata of all stored routines.
   */
  private $myMetadata = array();


  /** A map from placeholders to their actual values.
   */
  private $myReplacePairs = array();


  /** @name Current
     @{
     Properties with data about the current stored routine and/or .psql file.
  */
  /** The current .psql filename.
   */
  private $myCurrentPsqlFileName;


  /** The source code as a single string of the current .psql file.
   */
  private $myCurrentPsqlSourceCode;


  /** The source code as an array of lines string of the current .psql file.
   */
  private $myCurrentPsqlSourceCodeLines;


  /** The placeholders in the current .psql file.
   */
  private $myCurrentPlaceholders;


  /** The designation type of the stored routine in the current .psql file.
   */
  private $myCurrentType;

  /** The routine type (i.e. procedure or function) of the stored routine in the current .psql file.
   */
  private $myCurrentRoutineType;
  
  /** The name of the stored routine in the current .psql file.
   */
  private $myCurrentRoutineName;

  /** The key or index columns (depending on the designation type) of the stored routine in the current .psql file.
   */
  private $myCurrentColumns;

  /** @} */


  /** The exits status of this program.
   */
  private $myExitStatus = 0;



  //--------------------------------------------------------------------------------------------------------------------
  /** Returns the value of a setting.
      @param $theSettings      The settings as returned by @c parse_ini_file.
      @param $theMandatoryFlag If set and setting @a $theSettingName is not found in section @a $theSectionName an
                               exception will be thrown.
      @param $theSectionName   The name of the section of the requested setting.
      @param $theSettingName   The name of the setting of the requested setting.
   */
  private function GetSetting( $theSettings, $theMandatoryFlag, $theSectionName, $theSettingName )
  {
    // Test if the section exists.
    if (!array_key_exists( $theSectionName, $theSettings ))
    {                                
      if ($theMandatoryFlag)
      { 
        set_assert_failed( "Section '%s' not found in configuration file.", $theSectionName );
      }   
      else
      {
        return null;    
      }
    }                              
                                 
    // Test if the setting in the section exists.
    if (!array_key_exists( $theSettingName, $theSettings[$theSectionName] ))
    {
      if ($theMandatoryFlag)
      {
        set_assert_failed( "Setting '%s' not found in section '%s' configuration file.", $theSettingName, $theSectionName );
      } 
      else
      {
        return null;
      }
    }
    
    return $theSettings[$theSectionName][$theSettingName];
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Reads parameters from configuration @a $theConfigFileName
   */
  private function ReadConfigFile( $theConfigFileName )
  {
    $settings = parse_ini_file( $theConfigFileName, true );
    if ($settings===false) set_assert_failed( "Unable open configuration file" );

    $this->myIncludePath           = $this->GetSetting( $settings, true,  'loader',  'psql' );
    $this->myMetadataFilename      = $this->GetSetting( $settings, true,  'wrapper', 'metadata');
    $this->mySqlColumnTypeFileName = $this->GetSetting( $settings, true,  'loader',  'column_types_sql' );
    $this->myTargetConfigFileName  = $this->GetSetting( $settings, false, 'loader',  'config' );
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Reads constants set in @c myTargetConfigFileName and adds them to @c myReplacePairs.
   */
  private function GetConstants()
  {  
    // If myTargetConfigFileName is not set return immediatly.
    if (!isset($this->myTargetConfigFileName)) return;
      
    if (!is_readable( $this->myTargetConfigFileName )) set_assert_failed( "Configuration file is not readable '%s'.",
                                                                           $this->myTargetConfigFileName );
  
    require_once( $this->myTargetConfigFileName );
    $constants    = get_defined_constants(true);
    $user_defined = $constants['user'];
    
    foreach( $user_defined as $name => $value )
    {
      if (!is_numeric( $value )) $value = "'$value'"; 
      
      $this->myReplacePairs['@'.$name.'@'] = $value;
    }
  }

  // -------------------------------------------------------------------------------------------------------------------
  private function FindPsqlFiles( $theSourceDir=null )
  {
    if($theSourceDir===null) $theSourceDir = $this->myIncludePath;

    $psql_file_names = glob( "$theSourceDir/*.psql" );
    $file_names      = scandir( $theSourceDir );

    $this->myPsqlFileNames = array_merge( $this->myPsqlFileNames, $psql_file_names );

    $dir_names = array();
    foreach( $file_names as $file_name )
    {
      if (is_dir( $theSourceDir.'/'.$file_name ))
      {
        if ($file_name!='.' && $file_name!='..')
        {
          $dir_names[] = $theSourceDir.'/'.$file_name;
        }
      }
    }

    foreach( $dir_names as $dir_name )
    {
      $this->FindPsqlFiles( $dir_name );
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /** Returns the metadata @a myMetadata of stored routines stored in file.
   */
  private function ReadRoutineMetaData()
  {
    $handle = fopen( $this->myMetadataFilename, 'r' );
    if ($handle===null) set_assert_failed( "Unable to open file '%s'.", $this->myMetadataFilename );

    // Skip header row.
    fgetcsv( $handle, 1000, ',' );

    while (($row = fgetcsv( $handle, 1000, ',' ))!==false)
    {
      $metadata[$row[0]] = array( 'routine_name'   => $row[0],
                                  'type'           => $row[1],
                                  'argument_types' => $row[2],
                                  'columns'        => $row[3] );

    }

    $err = fclose( $handle );
    if ($err===false) set_assert_failed( "Error closing file '%s'.", $this->myMetadataFilename );

    $this->myMetadata = $metadata;
   }

  // -------------------------------------------------------------------------------------------------------------------
  /** Exracts the placeholders from the current psql file and stored them in @c myCurrentPlaceholders.
      Returns @c true if all placeholders are defined, @c false otherwise.
  */
  private function GetCurrentPlaceholders()
  {
    $err = preg_match_all( "(@[A-Za-z0-9\_\.]+(\%type)?@)", $this->myCurrentPsqlSourceCode, $matches );
    if ($err===false) set_assert_failed( 'Internal error.' );
    
    $ret = true;
    $this->myCurrentPlaceholders = array();
        
    if (!empty($matches[0]))
    {
      foreach( $matches[0] as $placeholder )
      {
        if (!isset($this->myReplacePairs[strtoupper( $placeholder )]))
        {
          echo sprintf( "Error: Unknown placeholder '%s' in file '%s'.\n", $placeholder, $this->myCurrentPsqlFileName );
          $ret = false;
        }
      
        if (!isset($this->myCurrentPlaceholders[$placeholder]))
        {
          $this->myCurrentPlaceholders[$placeholder] = $placeholder;
        }
      }
    }
    
    return $ret;
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Extracts the designation type of the current stored routine and sets @c myCurrentType and @c myCurrentColumns.
      Returns @c true on success. Otherwise returns @c false.
   */
  private function GetType()
  {
    $ret = true;  
    $key = array_search( 'begin', $this->myCurrentPsqlSourceCodeLines );

    if ($key!==false) 
    {    
      $n = preg_match( "/^\s*--\s+type:\s*(\w+)\s*(\w+)?\s*/", $this->myCurrentPsqlSourceCodeLines[$key-1], $matches );
      if ($n===false) set_assert_failed( "Internal error." );
      
      if ($n==1)
      {
        $this->myCurrentType    = $matches[0];
        $this->myCurrentColumns = $matches[1];
      }
      else
      {
        $ret = false;
      }
    }
    else
    {
      $ret = false;
    }
    
    if ($ret===false)
    {
      echo sprintf( "Error: Unable to find the desgination type of the stored routine in file '%s'.", 
                    $this->myCurrentPsqlFileName );
    }
    
    return $ret;
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Extracts the name of the stored routine and the stored routine type (i.e. procedure or function) and sets
      @c myCurrentRoutineType and @c myCurrentRoutineName. Returns @c true on success. Otherwise returns @c false.
      
      @todo Skip comments and string literals.
   */
  private function GetName()
  {
    $ret = true;
    
    $n = preg_match( "/create\s*(procedure|function)\s*([a-zA-Z0-9_]+)/i", $this->myCurrentPsqlSourceCode, $matches );
    if ($n===false) set_assert_failed( 'Internal error.' );   
        
    if ($n==1)
    {     
      $this->myCurrentRoutineName = $matches[2]; 
      $this->myCurrentRoutineType = strtolower( $matches[1] ); 
    
      if (!$this->myCurrentRoutineName==basename( $this->myCurrentPsqlFileName, '.psql' ))
      {
        echo sprintf( "Error: Stored routine name '%s' does not match filename in file '%s'.\n",
                      $this->myCurrentRoutineName,
                      $this->myCurrentPsqlSourceFileName );
        $ret = false;
      }   
    }
    else
    {
      unset($this->myCurrentRoutineName);
      unset($this->myCurrentRoutineType);
      $ret = false;      
    }
    
    if (!isset($this->myCurrentRoutineName))
    {
      echo sprintf( "Error: Unable to find the stored routine name and type in file '%s'.\n", 
                    $this->myCurrentPsqlFileName );
    }
    
    return $ret;
  }
   
  // -------------------------------------------------------------------------------------------------------------------
  private function LoadPsqlFile()
  {
    try
    {
      // Read the psql source code.
      $this->myCurrentPsqlSourceCode = file_get_contents( $this->myCurrentPsqlFileName );
      if ($this->myCurrentPsqlSourceCode===false)
      {
        set_assert_failed( "Unable to read file '%s'.", $this->myCurrentPsqlFileName );
      }
      
      // Split the psql source code into lines.
      $this->myCurrentPsqlSourceCodeLines =  explode( "\n", $this->myCurrentPsqlSourceCode );
      
      
      $ok = $this->GetCurrentPlaceholders( $this->myCurrentPsqlSourceCode, $this->myCurrentPsqlFileName );    
      if ($ok===false)
      {
        $this->myExitStatus = -1;
        return;
      }
     
      $ok = $this->GetType();
      if ($ok===false)
      {
        $this->myExitStatus = -1;
        return;
      }
      
      $ok = $this->GetName();
      if ($ok===false)
      {
        $this->myExitStatus = -1;
        return;
      }
  
      foreach( $this->myCurrentPlaceholders as $placeholder )
      {   
        $replace[$placeholder] = $this->myReplacePairs[strtoupper( $placeholder )];  
      }
     
      echo sprintf( "Loading %s %s\n", 
                    $this->myCurrentRoutineType,
                    $this->myCurrentRoutineName );
      
      
      $sql_source = strtr( $this->myCurrentPsqlSourceCode , $replace );
     
      // Drop the stored procedure or function if its exists.
      $sql = sprintf( "drop %s if exists %s",
                      $this->myCurrentRoutineType,
                      $this->myCurrentRoutineName );
      SET_DL::ExecuteNone( $sql );
      
      
      // Load the stored routine into MySQL.
      SET_DL::ExecuteNone( $sql_source );
      
      
      // Update the metadata of the stored routine.
      $this->myMetadata[$this->myCurrentRoutineName]['type']    = $this->myCurrentType;
      $this->myMetadata[$this->myCurrentRoutineName]['columns'] = $this->myCurrentColumns;        
    }
    catch (Exception $e)
    {
      echo $e->getMessage();
      
      unset( $this->myMetadata[$this->myCurrentRoutineName] );
    }
  }

  // -------------------------------------------------------------------------------------------------------------------
  /** Selects schema, table, and colum names and the column type from the MySQL and the column type placeholders
      to @c myReplacePairs.
   */
  private function GetColumnTypes()
  {
    $query = file_get_contents( $this->mySqlColumnTypeFileName );
    if ($query===false) set_assert_failed( "Unable to read file '%s'.", $this->mySqlColumnTypeFileName );

    $rows = SET_DL::ExecuteRows( $query );

    foreach( $rows as $row )
    {
      $key = '@';
      if (isset($row['table_schema'])) $key .= $row['table_schema'].'.';
      $key .= $row['table_name'].'.'.$row['column_name'].'%type@';
      $key = strtoupper( $key );

      $value = $row['column_type'];
      if (isset($row['character_set_name'])) $value .= ' character set '.$row['character_set_name'];

      $this->myReplacePairs[$key] = $value;
    }
  }

  // -------------------------------------------------------------------------------------------------------------------
  public function Main( $theConfigFileName )
  {
    SET_DL::Connect( 'localhost', 'nahouw', 'nahouw', 'nahouw' );

    $this->ReadConfigFile( $theConfigFileName );
    $this->FindPsqlFiles();
    $this->GetColumnTypes();
    $this->ReadRoutineMetaData();
    $this->GetConstants();
    
    foreach( $this->myPsqlFileNames as $this->myCurrentPsqlFileName )
    {
      $this->LoadPsqlFile();
    }
    
    //GetStoredRoutines();
    
    /* @todo
       * Get all stored routines and argument list from MySQL
       * update myMetadata (set arguments, remove from myMetadata stored routine not found in list
       * save metadata
    */

     /** @todo
         * add option drop routine if .psql file doesn't exists.
         * drop obsolete routines
     */

     SET_DL::Disconnect();
  }

  // -------------------------------------------------------------------------------------------------------------------
}

// ---------------------------------------------------------------------------------------------------------------------
function Synopsis()
{
  echo "routine_loader <configfile> [routine.psql]\n";
  exit(1);
}

// ---------------------------------------------------------------------------------------------------------------------
if($argc!=2) Synopsis();

$loader = new SET_RoutineLoader;
$loader->Main( $argv[1] );

/** @todo
   * Improve own DataLayer and add options
   * Add file with dependencies per stored routine (i.e. source path, timestamp, placeholders)
   * Only load if dependencies have changed or file is new.
   * Implement 2 parameter for this program
   * Implement locking
   */
